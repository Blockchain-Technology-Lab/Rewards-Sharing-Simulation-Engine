{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cardano Pooling Simulator\u2019s Documentation This is the documentation for the Cardano Pooling Simulation Engine built by the University of Edinburgh's Blockchain Technology Lab. The source code is available on Github . Overview The simulation models the behaviour of stakeholders in a Proof-of-Stake system, i.e. the way they use their stake to engage with the protocol depending on the rewards they expect to receive. It focuses particularly on the way different stakeholders combine their resources and create stake pools (it assumes an on-chain pooling mechanism like the one in Cardano) and follows the dynamics of the system until it (potentially) reaches an equilibrium. The implementation is based on the Cardano blockchain, but can be generalized to systems that use similar reward sharing schemes (e.g. Nym ). The simulation engine can be used to play out different scenarios and better understand the relationship between the system's input (e.g. parameters of the reward scheme or initial stake distribution) and its convergence properties (does it converge to an equilibrium and if yes how quickly, how decentralized is the final allocation of stake to the different stakeholders, and so on). For details on how to install the engine and run simulations, see the Setup page; for a complete guide on how to customize the simulation, see the Configuration page; for a description of the different output files that a simulation produces, see the Output page, and for examples to get started with and draw inspiration from, see the Examples page. If you have questions about the project that are not covered in the documentation or any other remark you would like to share with us and the wider community, please visit our dedicated Discussions section on Github and start a new thread or participate in an existing discussion if it is relevant to your concern. Contributing This is an open source project licensed under the terms and conditions of the Apache 2.0 license . Everyone is welcome to contribute to it by proposing or implementing their ideas. Example contributions include, but are not limited to, adding a new feature to the simulation engine (e.g. integration of exchange rates), improving the performance of the simulations, or creating a user-friendly interface for configuring and running simulations. Note that all contributions to the project will be covered by the above-mentioned license.","title":"Home"},{"location":"#cardano-pooling-simulators-documentation","text":"This is the documentation for the Cardano Pooling Simulation Engine built by the University of Edinburgh's Blockchain Technology Lab. The source code is available on Github .","title":"Cardano Pooling Simulator\u2019s Documentation"},{"location":"#overview","text":"The simulation models the behaviour of stakeholders in a Proof-of-Stake system, i.e. the way they use their stake to engage with the protocol depending on the rewards they expect to receive. It focuses particularly on the way different stakeholders combine their resources and create stake pools (it assumes an on-chain pooling mechanism like the one in Cardano) and follows the dynamics of the system until it (potentially) reaches an equilibrium. The implementation is based on the Cardano blockchain, but can be generalized to systems that use similar reward sharing schemes (e.g. Nym ). The simulation engine can be used to play out different scenarios and better understand the relationship between the system's input (e.g. parameters of the reward scheme or initial stake distribution) and its convergence properties (does it converge to an equilibrium and if yes how quickly, how decentralized is the final allocation of stake to the different stakeholders, and so on). For details on how to install the engine and run simulations, see the Setup page; for a complete guide on how to customize the simulation, see the Configuration page; for a description of the different output files that a simulation produces, see the Output page, and for examples to get started with and draw inspiration from, see the Examples page. If you have questions about the project that are not covered in the documentation or any other remark you would like to share with us and the wider community, please visit our dedicated Discussions section on Github and start a new thread or participate in an existing discussion if it is relevant to your concern.","title":"Overview"},{"location":"#contributing","text":"This is an open source project licensed under the terms and conditions of the Apache 2.0 license . Everyone is welcome to contribute to it by proposing or implementing their ideas. Example contributions include, but are not limited to, adding a new feature to the simulation engine (e.g. integration of exchange rates), improving the performance of the simulations, or creating a user-friendly interface for configuring and running simulations. Note that all contributions to the project will be covered by the above-mentioned license.","title":"Contributing"},{"location":"configuration/","text":"Configuration The simulation engine is highly configurable. From the reward scheme parameters to be used to the output files to be generated, there are numerous variables that can vary from execution to execution. This customisation is performed using command-line arguments when running the main.py or batch-run.py scripts. We will go through all the available options here, but it's also possible to get an overview of the arguments and their default values by running the corresponding help commands: python main.py --help python batch-run.py --help Command-line options These are all the arguments that can be configured during execution from the command line. --n : The number of stakeholders / agents in the simulation. The default value is 1000 , but any natural number is accepted. Note that the higher the value of n the slower the simulation becomes. --k : The target number of pools of the system (reward sharing scheme parameter). The default value is 100 , but any natural number < n is accepted. Note that the higher the value of k the slower the simulation becomes. --a0 : Stake influence factor (reward sharing scheme parameter). The default value is 0.3 , but any non-negative real number is accepted.","title":"Configuration"},{"location":"configuration/#configuration","text":"The simulation engine is highly configurable. From the reward scheme parameters to be used to the output files to be generated, there are numerous variables that can vary from execution to execution. This customisation is performed using command-line arguments when running the main.py or batch-run.py scripts. We will go through all the available options here, but it's also possible to get an overview of the arguments and their default values by running the corresponding help commands: python main.py --help python batch-run.py --help","title":"Configuration"},{"location":"configuration/#command-line-options","text":"These are all the arguments that can be configured during execution from the command line. --n : The number of stakeholders / agents in the simulation. The default value is 1000 , but any natural number is accepted. Note that the higher the value of n the slower the simulation becomes. --k : The target number of pools of the system (reward sharing scheme parameter). The default value is 100 , but any natural number < n is accepted. Note that the higher the value of k the slower the simulation becomes. --a0 : Stake influence factor (reward sharing scheme parameter). The default value is 0.3 , but any non-negative real number is accepted.","title":"Command-line options"},{"location":"examples/","text":"Examples Here, we provide some examples that can help better understand the capacities of the simulation engine. We divide the examples in sections, depending on the type of execution (single run or batch run). Note that in all examples below, we assume that the python command corresponds to a Python 3.9 installation and that the commands are executed from the root directory of the project. Recall that when an argument is not set explicitly then its default value is used (for all arguments and their default values see the Configuration ) page). Single runs Run with 1000 agents, k = 100 and a0 = 0.3: python main.py --n=1000 --k=100 --a0=0.3 --execution_id=baseline Run with two phases, first with k = 100 and then k = 200: python main.py --k 100 200 --execution_id=increasing-k Run with 10,000 agents, k = 500 and a specified seed (42): python main.py --n=10000 --k=1000 --seed=42 --execution_id=n-10K-k-1000-seed-42 Batch runs Batch run with 1000 agents and a range of 5 different values for k (100, 200, 300, 400, 500): python batch-run.py --n=1000 --k 100 501 100 --execution_id=batch-run-varying-k Batch run with 1000 agents, k = 100 and a range of 5 values for a0 (0.001, 0.01, 0.1, 1, 10): python batch-run.py --n=1000 --k=100 --a0 -3 1 5 --execution_id=batch-run-varying-a0-log","title":"Examples"},{"location":"examples/#examples","text":"Here, we provide some examples that can help better understand the capacities of the simulation engine. We divide the examples in sections, depending on the type of execution (single run or batch run). Note that in all examples below, we assume that the python command corresponds to a Python 3.9 installation and that the commands are executed from the root directory of the project. Recall that when an argument is not set explicitly then its default value is used (for all arguments and their default values see the Configuration ) page).","title":"Examples"},{"location":"examples/#single-runs","text":"Run with 1000 agents, k = 100 and a0 = 0.3: python main.py --n=1000 --k=100 --a0=0.3 --execution_id=baseline Run with two phases, first with k = 100 and then k = 200: python main.py --k 100 200 --execution_id=increasing-k Run with 10,000 agents, k = 500 and a specified seed (42): python main.py --n=10000 --k=1000 --seed=42 --execution_id=n-10K-k-1000-seed-42","title":"Single runs"},{"location":"examples/#batch-runs","text":"Batch run with 1000 agents and a range of 5 different values for k (100, 200, 300, 400, 500): python batch-run.py --n=1000 --k 100 501 100 --execution_id=batch-run-varying-k Batch run with 1000 agents, k = 100 and a range of 5 values for a0 (0.001, 0.01, 0.1, 1, 10): python batch-run.py --n=1000 --k=100 --a0 -3 1 5 --execution_id=batch-run-varying-a0-log","title":"Batch runs"},{"location":"output/","text":"Output Every time the simulation engine is used, it produces some output files to describe the simulations that were executed. All these files are saved within a folder named \u201coutput\u201d, which is created automatically if it doesn't already exist. Output from single run Each execution of the simulation generates a new folder for the output of that specific execution. The folder is named based on the local serial number 1 of the execution and a user-provided identifier (or an automatically generated one if the user does not define one for that instance). Specifically, the folder is populated with the following: Files that characterize the input of the execution args.json : A json file that lists all the parameters of the simulation and the values they take during this execution. initial-state-descriptors.json : A json file that describes the initial state of the system for this execution, including the highest and lowest stake values owned by the stakeholders, the Nakamoto coefficient prior (how many stakeholders collectively control the majority of the stake before any pooling takes place), and more. The number that was used as the seed for pseudo-randomness is also listed there, to allow for reproducibility of the results. Files that track the evolution of the execution metrics.csv : A csv file that reports various metrics for each round of the simulation (e.g. pool count or total pledge). The specific metrics that are tracked depend on the input of the simulation (see the relevant part of the Configuration page for all options). Figures : If the relevant option is activated (see Configuration ), a graph is produced for each tracked metric, illustrating its evolution throughout the course of the simulation. Files that characterize the outcome of the execution final-state-descriptors.json : A json file that describes the final state of the system for this execution, including the number of pools, the number of distinct operators, and more. It is also stated in this file whether the simulation reached an equilibrium or not. final-state-pools.csv : A csv file that lists information about the pools that are active in the system upon termination of the simulation. This includes for each pool its owner's id, its pledge, total stake, profit margin, and more. final-state-stakeholders.csv : A csv file that lists information about the stakeholders upon termination of the simulation. This includes predetermined attributes, like the initial stake or cost value of a stakeholder, as well as characteristics relating to the final state of the simulation, such as the number of pools they end up operating or the total stake they control through their pools. simulation-object.pkl : A pickled file containing the instance of the simulation as a Python object (only useful for developers that may want to use it to extract more data). For example, running the simulation for the first time with \"simulation-test\" as the execution id produces a folder that looks like this: Output from batch run Similarly with the single run, each batch run execution generates a new folder, which is named based on the local serial number and a user-provided identifier (or the generic \"batch-run\" if the user does not define an id for that instance). Within this folder, more folders are created, each corresponding to an instance of the simulation and having the format described above. In the case of batch runs, one more file is created, which contains aggregate results (some metrics for each simulation instance) and is used to create graphs (saved under \"Figures\") and compare the different executions and the impact of the changing input. For example, executing a batch run the second time the simulation engine is used, with \"batch-run-varying-k\" as the execution id produces a folder that looks like this: 1 : Keeping track of the serial number is done using a local file named \"sequence.dat\".","title":"Output"},{"location":"output/#output","text":"Every time the simulation engine is used, it produces some output files to describe the simulations that were executed. All these files are saved within a folder named \u201coutput\u201d, which is created automatically if it doesn't already exist.","title":"Output"},{"location":"output/#output-from-single-run","text":"Each execution of the simulation generates a new folder for the output of that specific execution. The folder is named based on the local serial number 1 of the execution and a user-provided identifier (or an automatically generated one if the user does not define one for that instance). Specifically, the folder is populated with the following:","title":"Output from single run"},{"location":"output/#files-that-characterize-the-input-of-the-execution","text":"args.json : A json file that lists all the parameters of the simulation and the values they take during this execution. initial-state-descriptors.json : A json file that describes the initial state of the system for this execution, including the highest and lowest stake values owned by the stakeholders, the Nakamoto coefficient prior (how many stakeholders collectively control the majority of the stake before any pooling takes place), and more. The number that was used as the seed for pseudo-randomness is also listed there, to allow for reproducibility of the results.","title":"Files that characterize the input of the execution"},{"location":"output/#files-that-track-the-evolution-of-the-execution","text":"metrics.csv : A csv file that reports various metrics for each round of the simulation (e.g. pool count or total pledge). The specific metrics that are tracked depend on the input of the simulation (see the relevant part of the Configuration page for all options). Figures : If the relevant option is activated (see Configuration ), a graph is produced for each tracked metric, illustrating its evolution throughout the course of the simulation.","title":"Files that track the evolution of the execution"},{"location":"output/#files-that-characterize-the-outcome-of-the-execution","text":"final-state-descriptors.json : A json file that describes the final state of the system for this execution, including the number of pools, the number of distinct operators, and more. It is also stated in this file whether the simulation reached an equilibrium or not. final-state-pools.csv : A csv file that lists information about the pools that are active in the system upon termination of the simulation. This includes for each pool its owner's id, its pledge, total stake, profit margin, and more. final-state-stakeholders.csv : A csv file that lists information about the stakeholders upon termination of the simulation. This includes predetermined attributes, like the initial stake or cost value of a stakeholder, as well as characteristics relating to the final state of the simulation, such as the number of pools they end up operating or the total stake they control through their pools. simulation-object.pkl : A pickled file containing the instance of the simulation as a Python object (only useful for developers that may want to use it to extract more data). For example, running the simulation for the first time with \"simulation-test\" as the execution id produces a folder that looks like this:","title":"Files that characterize the outcome of the execution"},{"location":"output/#output-from-batch-run","text":"Similarly with the single run, each batch run execution generates a new folder, which is named based on the local serial number and a user-provided identifier (or the generic \"batch-run\" if the user does not define an id for that instance). Within this folder, more folders are created, each corresponding to an instance of the simulation and having the format described above. In the case of batch runs, one more file is created, which contains aggregate results (some metrics for each simulation instance) and is used to create graphs (saved under \"Figures\") and compare the different executions and the impact of the changing input. For example, executing a batch run the second time the simulation engine is used, with \"batch-run-varying-k\" as the execution id produces a folder that looks like this: 1 : Keeping track of the serial number is done using a local file named \"sequence.dat\".","title":"Output from batch run"},{"location":"setup/","text":"Setup Dependencies The simulation engine is written in Python 3.9, so the first thing to ensure when running it on some machine is that Python 3.9 is installed there. The remaining dependencies of the project can be found in the requirements file . Running the following from the root directory of the project installs all required packages in one go (assuming that the python command corresponds to a Python 3.9 installation): python -m pip install -r requirements.txt Installation Installing the simulation engine is very simple, as it only involves cloning the relevant Github project : git clone https://github.com/Blockchain-Technology-Lab/Cardano-Pooling-Simulator.git Execution To run the simulation, navigate to the directory of the project and run the main.py script from a terminal: python main.py This executes the simulation with the default options (1000 agents, k = 100, a0 = 0.3, and so on). It is also possible to run the simulation with different parameters. For example, to if we want a simulation with 10,000 agents and target number of pools k = 500, we can run the following: python main.py --n=10000 --k=500 For the full list of options that the simulation accepts, refer to the Configuration page, and for examples of using the simulation engine in different ways see the Examples page.","title":"Setup"},{"location":"setup/#setup","text":"","title":"Setup"},{"location":"setup/#dependencies","text":"The simulation engine is written in Python 3.9, so the first thing to ensure when running it on some machine is that Python 3.9 is installed there. The remaining dependencies of the project can be found in the requirements file . Running the following from the root directory of the project installs all required packages in one go (assuming that the python command corresponds to a Python 3.9 installation): python -m pip install -r requirements.txt","title":"Dependencies"},{"location":"setup/#installation","text":"Installing the simulation engine is very simple, as it only involves cloning the relevant Github project : git clone https://github.com/Blockchain-Technology-Lab/Cardano-Pooling-Simulator.git","title":"Installation"},{"location":"setup/#execution","text":"To run the simulation, navigate to the directory of the project and run the main.py script from a terminal: python main.py This executes the simulation with the default options (1000 agents, k = 100, a0 = 0.3, and so on). It is also possible to run the simulation with different parameters. For example, to if we want a simulation with 10,000 agents and target number of pools k = 500, we can run the following: python main.py --n=10000 --k=500 For the full list of options that the simulation accepts, refer to the Configuration page, and for examples of using the simulation engine in different ways see the Examples page.","title":"Execution"}]}